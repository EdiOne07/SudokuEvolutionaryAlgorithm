\section{Genetic Algorithm}
\label{sec:algorithm}

\textcolor{red}{The third section should present the evolutionary approach you developed. You can divide this section into subsection. In any case, you should mention the following details:}

\textcolor{red}{\textbf{Evolutionary approach.} Clearly describe the algorithm you developed. You should clearly explain the evolutionary operators you used and what modifications you did to match the problem. It is extremely important to present also a pseudocode of your algorithm. An example is given in \ref{alg:pseudocode_example}, below. For more insight into presentation of algorithms, you can advise \cite{zobel2014algorithms}.}

{
\color{red}To typeset pseudocode in \LaTeX\ you can use one of the following options:
\begin{itemize}
    \item Choose ONE of the (\texttt{algpseudocode} OR \texttt{algcompatible} OR \texttt{algorithmic}) packages to typeset algorithm bodies, and the algorithm package for captioning the algorithm.
    \item The \texttt{algorithm2e} package.
\end{itemize}
You can find more information here: \url{https://www.overleaf.com/learn/latex/Algorithms}
}

\begin{algorithm}
\caption{Example of an algorithm's pseudocode}\label{alg:pseudocode_example}
\begin{algorithmic}
\Require $n \geq 0$
\Ensure $y = x^n$
\State $y \gets 1$
\State $X \gets x$
\State $N \gets n$
\While{$N \neq 0$}
\If{$N$ is even}
    \State $X \gets X \times X$
    \State $N \gets \frac{N}{2}$  \Comment{This is a comment}
\ElsIf{$N$ is odd}
    \State $y \gets y \times X$
    \State $N \gets N - 1$
\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

\textcolor{red}{\textbf{Solution representation.} Clearly describe the solution representation you used. You can use figures to improve the comprehensibility of this part.}

\textcolor{red}{\textbf{Fitness function.} It is also very important to mention the fitness function you used. In many cases, the objective function of the problem is not the same as the fitness function used in an evolutionary algorithm. An example, following the principles of \cite{zobel2014mathematics}, is given below.}

\begin{equation}
    F = \sum_{i=1}^d x_i^2 
\end{equation}
where $x_i$ is the $i$-th gene (i.e., decision variable) in the solution and $d$ corresponds to the number of decision variables in the problem.

\textcolor{red}{\textbf{Note:} Change the section's title to match the name of the algorithm you developed for your assignment.}

\subsection{Implementations}
This section presents and compares different implementations of an evolutionary algorithm designed to solve Sudoku puzzles. Each implementation varies in its approach to selection, crossover, mutation strategies, and fitness evaluation.

The following sections document these processes and use the Sudoku board shown in \ref{fig:initial-sudoku} as a reference for visualizing the selection and mutation step.

\begin{figure}[H]
\centering
\resizebox{0.5\textwidth}{!}{
  \begin{minipage}{\textwidth}
    \begin{sudoku}
    | |2| | | | | |3|1|.
    |7| | | | |3| | | |.
    | | | |1|4| |2|9| |.
    | |5|2|7|6|4| |1|8|.
    | |6|3| |1|2|7|5|9|.
    | |7|8| | | |4| | |.
    |2| | |3|7| | | |5|.
    | |1| | | | |9| | |.
    |5|4| | |8|1| | | |.
    \end{sudoku}
  \end{minipage}%
}
\caption{Initial Sudoku puzzle}
\label{fig:initial-sudoku}
\end{figure}

\subsubsection{Baseline}
Depth-first search (DFS) is used as a deterministic baseline. The solver iteratively scans the board for the first empty cell, attempts candidate values 1\dots n, and backtracks to try alternative values if no candidate leads to a solution. This approach is ensures a solution (given that the puzzle is solvable) and is simple to implement, which makes it a reliable reference for correctness and for measuring runtimes.
Algorithm \ref{alg:dfs} shows the implementation of the DFS algorithm in pseudo-code.

\begin{algorithm}[H]
\caption{Depth-first search algorithm}\label{alg:dfs}
\begin{algorithmic}
\Require matrix
\Ensure \textbf{true} if solved, \textbf{false} otherwise
\State $n \gets$ length(matrix)
\For{$i \leftarrow 1$ \textbf{to} $n$}
  \For{$j \leftarrow 1$ \textbf{to} $n$}
    \If{matrix[$i,j$] = 0}
      \For{$num \leftarrow 1$ \textbf{to} $n$}
        \If{is\_valid\_move(matrix, $i$, $j$, $num$)}
          \State matrix[$i,j$] $\gets$ $num$
          \If{\Call{DFS}{matrix}} \State \Return \textbf{true} \EndIf
          \State matrix[$i,j$] $\gets$ 0
        \EndIf
      \EndFor
      \State \Return \textbf{false}
    \EndIf
  \EndFor
\EndFor
\State \Return \textbf{true}
\end{algorithmic}
\end{algorithm}

\pagebreak % TODO: make sure this is properly formatted, but if we dont pagebreak here, then the next paragraph might appear above the table, which is not good.
\subsubsection{Implementation 1}\label{sec:impl-1}

Algorithm \ref{alg:impl-1} gives an overview of how the algorithm works. A detailed description of how the fitness function, crossover, and mutation work, will be given afterwards.

\begin{algorithm}[H]
\caption{Genetic Algorithm 1}\label{alg:impl-1}
\begin{algorithmic}
\Require $initial\_sudoku$, $population\_size$, $mutation\_rate$, $max\_generations$
\Ensure Best individual found
\State $population \gets$ PopulateRandomly($initial\_sudoku$, $population\_size$)
\State $generation \gets 0$
\While{$generation < max\_generations$}
  \State $population \gets$ SortByFitness($population$) \Comment{descending order}
  \If{Fitness(first($population$)) = $max\_fitness$}
    \State \Return first($population$)
  \EndIf
  \State $next\_generation \gets \emptyset$
  \For{$i \gets 1 \ \textbf{to} \ population\_size \times 0.8$}
    \State $parent_1, parent_2 \gets$ Sample(top 20\% of $population$)
    \State $child \gets$ Crossover($parent_1$, $parent_2$)
    \State $child \gets$ Mutate($child$, $mutation\_rate$, $initial\_sudoku$)
    \State $next\_generation \gets next\_generation \cup \{child\}$
  \EndFor
  \For{$i \gets 1 \ \textbf{to} \ population\_size \times 0.2$}
    \State $parent_1, parent_2 \gets$ Sample($population$)
    \State $child \gets$ Crossover($parent_1$, $parent_2$)
    \State $child \gets$ Mutate($child$, $mutation\_rate$, $initial\_sudoku$)
    \State $next\_generation \gets next\_generation \cup \{child\}$
  \EndFor
  \State $population \gets next\_generation$
  \State $generation \gets generation + 1$
\EndWhile
\State $population \gets$ SortByFitness($population$) \Comment{descending order}
\State \Return first($population$)
\end{algorithmic}
\end{algorithm}


\paragraph{Fitness function}\label{par:ff-impl1} Let $R_i$, $C_j$ and $B_b$ denote the sets of distinct, non-zero digits present in row $i$, column $j$, and block $b$, respectively. Using zero-based indices $(i,j\in\{0,\dots,8\})$ the block index is
\[
b \;=\; 3\Big\lfloor\frac{i}{3}\Big\rfloor \;+\; \Big\lfloor\frac{j}{3}\Big\rfloor .
\]
The fitness of a board is the total number of distinct digits across all rows, columns and 3\(\times\)3 blocks:
\[
F \;=\; \sum_{i=0}^{8} |R_i| \;+\; \sum_{j=0}^{8} |C_j| \;+\; \sum_{b=0}^{8} |B_b|.
\]
This definition results in a maximum fitness score of $243$ for 9$\times$9 boards.

\paragraph{Crossover} A new individual is creating by crossing over two parents. The crossover process simply iterates over all the tiles that were not given in the initial puzzle and takes the value for that tile from either parent to copy it to the child.

\begin{figure}[H]
  \centering
  {\setlength{\tabcolsep}{-9pt}
  \renewcommand{\arraystretch}{1.5}
   \begin{tabular}{c c c c c}
    % first board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |6|2|9|5|7|6|7|3|1|.
        |7|8|5|6|9|3|1|2|7|.
        |1|3|4|1|4|7|2|9|5|.
        |4|5|2|7|6|4|4|1|8|.
        |9|6|3|8|1|2|7|5|9|.
        |9|7|8|2|9|5|4|6|2|.
        |2|2|6|3|7|7|9|4|5|.
        |4|1|6|2|2|3|9|7|9|.
        |5|4|1|2|8|1|3|4|8|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % plus sign
    {\begin{adjustbox}{valign=c}\Large$+$\end{adjustbox}}
    &
    % second board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |8|2|6|7|7|5|7|3|1|.
        |7|1|3|9|8|3|8|2|4|.
        |1|5|5|1|4|7|2|9|3|.
        |9|5|2|7|6|4|1|1|8|.
        |4|6|3|9|1|2|7|5|9|.
        |3|7|8|5|9|1|4|6|3|.
        |2|8|7|3|7|1|7|4|5|.
        |3|1|6|4|2|3|9|7|2|.
        |5|4|4|2|8|1|3|4|3|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % equals sign
    {\begin{adjustbox}{valign=c}\Large$=$\end{adjustbox}}
    &
    % third board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |8|2|9|7|7|6|7|3|1|.
        |7|1|5|6|8|3|1|2|4|.
        |1|3|5|1|4|7|2|9|5|.
        |9|5|2|7|6|4|1|1|8|.
        |9|6|3|8|1|2|7|5|9|.
        |3|7|8|5|9|1|4|6|3|.
        |2|2|6|3|7|7|7|4|5|.
        |4|1|6|4|2|3|9|7|9|.
        |5|4|1|2|8|1|3|4|3|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
   \end{tabular}
  }
  \caption{Exemplary selection step according to Implementation 1}
  \label{fig:impl-1-selection}
\end{figure}

In the figure above, two parents (left and middle) of the current generation form an individual of the next generation (right).
One area for improvement is evident in row 7: Parent~1 contains two occurrences of the digit 7 and Parent~2 contains three. The offspring also has three 7s, while it would have been possible to generate a row with all distinct digits, namely \textbf{286371945}.

\paragraph{Mutation} After the creation of a new individual, it undergoes up to $mutation\_amount$ mutations. A mutation means that a random tile changes its value. If that tile, however, happens to be a given tile from the initial puzzle, it is not altered. 

\begin{figure}[h]
  \centering
  {\setlength{\tabcolsep}{0pt}
  \renewcommand{\arraystretch}{1.5}
   \begin{tabular}{c c c}
    % first board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |8|2|9|7|7|6|7|3|1|.
        |7|1|5|6|8|3|1|2|4|.
        |1|3|5|1|4|7|2|9|5|.
        |9|5|2|7|6|4|1|1|8|.
        |9|6|3|8|1|2|7|5|9|.
        |3|7|8|5|9|1|4|6|3|.
        |2|2|6|3|7|7|7|4|5|.
        |4|1|6|4|2|3|9|7|9|.
        |5|4|1|2|8|1|3|4|3|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % plus sign
      {\begin{adjustbox}{valign=c}
       \shortstack{mutation\\[2pt]\Large$\longrightarrow$}
     \end{adjustbox}}
    &
    % second board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |8|2|9|7|7|6|7|3|1|.
        |7|1|5|6|8|3|1|2|4|.
        |1|3|5|1|4|7|2|9|5|.
        |9|5|2|7|6|4|1|1|8|.
        |9|6|3|8|1|2|7|5|9|.
        |3|7|8|5|9|1|4|6|3|.
        |2|2|6|3|7|7|7|7|5|.
        |4|1|6|4|2|3|9|7|9|.
        |5|4|1|2|8|1|3|4|3|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
   \end{tabular}
  }
  \caption{Exemplary mutation step according to Implementation 1}
  \label{fig:impl-1-mutation}
\end{figure}

Figure \ref{fig:impl-1-mutation} illustrates a mutation step with $mutation\_amount =2$. Meanwhile, only a single tile (row 7, column 7) was actually modified to have the value 7. The other candidate position coincided with a given cell and therefore could not be changed. This example highlights a weakness of the implementation: mutations can be wasted when selected positions are immutable, and a single mutation may decrease fitness significantly by introducing additional conflicts (the number of 7's increased to 4 in the respective row, to 2 in the respective column, and to 3 in the respective grid).

\paragraph{Problem}
This implementation leads to a situation where the diversity of the population decreases rapidly, resulting in convergence to suboptimal solutions. On many runs, the algorithm creates more than 100,000 generations before finding a valid solution.  
To counter this problem, we have tried to increase the mutation rate and the population size, as well as introducing new random individuals in each generation. However, these adjustments only led to marginal improvements in performance.

\subsubsection{Implementation 2}
The second genetic algorithm variant, which uses elitism and tournament selection, is presented in algorithm \ref{alg:impl-2}. 
Elitism ensures that the best $elite\_size$ individuals from the current generation are directly carried over to the next generation without modification.
Tournament selection is then applied to select parents for the remaining individuals: in each tournament, $K$ individuals are randomly chosen from the population, and the one with the best fitness is selected as a parent. This process is repeated until $population\_size$ parents have been chosen.

\begin{algorithm}[H]
\caption{Genetic Algorithm 2}\label{alg:impl-2}
\begin{algorithmic}
\Require $population\_size$, $elite\_size$, $max\_generations$
\Ensure Best individual found
\State $population \gets$ PopulateWithUniqueRows($population\_size$)
\State $best\_individual \gets$ arbitrary element of $population$
\For{$generation \gets 1 \ \textbf{to} \ max\_generations$}
  \ForAll{$ind \in population$}
    \State ComputeFitness($ind$)
  \EndFor
  \State $population \gets$ SortByFitness($population$) \Comment{ascending order}
  \If{Fitness(first($population$)) $<$ Fitness($best\_individual$)}
    \State $best\_individual \gets$ first($population$)
  \EndIf
  \If{Fitness($best\_individual$) = 0}
    \State \Return $best\_individual$
  \EndIf
  \State $next\_generation \gets$ Top($elite\_size$, $population$)
  \State $parents \gets$ TournamentSelection($population$)
  \For{$i \gets 1 \ \textbf{to} \ population\_size - elite\_size \ \textbf{step} \ 2$}
    \State $parent_1 \gets parents[i]$
    \State $parent_2 \gets parents[i+1]$
    \State $child_1 \gets$ Crossover($parent_1, parent_2$)
    \State $next\_generation \gets next\_generation \cup \{child_1\}$
    \If{$|next\_generation| < population\_size$}
      \State $child_2 \gets$ Crossover($parent_2, parent_1$)
      \State $next\_generation \gets next\_generation \cup \{child_2\}$
    \EndIf
  \EndFor
  \State $population \gets next\_generation$
\EndFor
\State \Return $best\_individual$
\end{algorithmic}
\end{algorithm}

\paragraph{Fitness function} Let \(C_j\) and \(B_b\) denote the sets of distinct, non-zero digits in column \(j\) and block \(b\), respectively, and let \(n\) be the board size. The fitness function counts the number of duplicates in each column, and 3x3 subgrid:
\[
F \;=\; \sum_{j=0}^{n-1} \bigl(n - |C_j|\bigr) \;+\; \sum_{b=0}^{n-1} \bigl(n - |B_b|\bigr).
\]
A value \(F=0\) indicates a valid solution.

\paragraph{Crossover} The crossover step is done by iterating through the rows of the sudoku board and copying each row from either parent. This ensures that the children will still respect the uniqueness of numbers in each row.

\begin{figure}[H]
  \centering
  {\setlength{\tabcolsep}{-9pt}
  \renewcommand{\arraystretch}{1.5}
   \begin{tabular}{c c c c c}
    % first board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |9|2|4|6|7|8|5|3|1|.
          |7|9|1|5|2|3|8|6|4|.
          |8|3|5|1|4|6|2|9|7|.
          |3|5|2|7|6|4|9|1|8|.
          |4|6|3|8|1|2|7|5|9|.
          |6|7|8|5|3|9|4|1|2|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|2|6|5|9|8|4|.
          |5|4|9|6|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % plus sign
    {\begin{adjustbox}{valign=c}\Large$+$\end{adjustbox}}
    &
    % second board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |8|2|4|7|9|6|5|3|1|.
          |7|9|1|5|2|3|6|8|4|.
          |3|6|7|1|4|8|2|9|5|.
          |3|5|2|7|6|4|9|1|8|.
          |8|6|3|4|1|2|7|5|9|.
          |1|7|8|5|3|9|4|2|6|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|8|5|6|9|4|2|.
          |5|4|6|9|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % equals sign
    {\begin{adjustbox}{valign=c}\Large$=$\end{adjustbox}}
    &
    % third board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |8|2|4|7|9|6|5|3|1|.
          |7|9|1|5|2|3|6|8|4|.
          |8|3|5|1|4|6|2|9|7|.
          |3|5|2|7|6|4|9|1|8|.
          |8|6|3|4|1|2|7|5|9|.
          |1|7|8|5|3|9|4|2|6|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|2|6|5|9|8|4|.
          |5|4|6|9|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
   \end{tabular}
  }
  \caption{Exemplary selection step according to Implementation 2}
  \label{fig:impl-2-selection}
\end{figure}

In figure~\ref{fig:impl-2-selection}, it is easy to see that the very first row is taken from the first parent (left), while row 8 is copied from the second parent (center). Duplicate numbers, as a result of the crossover step, can now only emerge in columns or subgrids, which is an improvement compared to \nameref{sec:impl-1}.

\paragraph{Mutation} For the mutation, we iterate all rows of an individual and swap two random tiles that both haven't been given in the initial sudoku. We do this with the probability of $mutation\_rate$ for each row, once again ensuring the uniqueness of numbers in each row.

\begin{figure}[H]
  \centering
  {\setlength{\tabcolsep}{0pt}
  \renewcommand{\arraystretch}{1.5}
   \begin{tabular}{c c c}
    % first board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |8|2|4|7|9|6|5|3|1|.
          |7|9|1|5|2|3|6|8|4|.
          |8|3|5|1|4|6|2|9|7|.
          |3|5|2|7|6|4|9|1|8|.
          |8|6|3|4|1|2|7|5|9|.
          |1|7|8|5|3|9|4|2|6|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|2|6|5|9|8|4|.
          |5|4|6|9|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % plus sign
      {\begin{adjustbox}{valign=c}
       \shortstack{mutation\\[2pt]\Large$\longrightarrow$}
     \end{adjustbox}}
    &
    % second board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |8|2|4|6|9|7|5|3|1|.
          |7|9|1|5|2|3|6|8|4|.
          |8|3|5|1|4|6|2|9|7|.
          |3|5|2|7|6|4|9|1|8|.
          |4|6|3|8|1|2|7|5|9|.
          |1|7|8|5|3|9|4|2|6|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|2|6|5|9|8|4|.
          |5|4|6|9|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
   \end{tabular}
  }
  \caption{Exemplary mutation step according to Implementation 2}
  \label{fig:impl-2-mutation}
\end{figure}

The mutation of the individual that resulted from the previous crossover is shown in figure~\ref{fig:impl-2-mutation}. For this example, the mutation rate was set to 20\%, leading to mutations in row 1 and row 5. 

\paragraph{Problem}
The second genetic algorithm also often converges to local optima and loses diversity, which limits further improvement. One solution was to apply adaptive mutation rates in order to increase the diversity, but that did not solve all local optima problems. Another approach would be to inject new genetic material (e.g. periodically replace most of the population), but that measure was not implemented due to time constraints. Furthermore, scalability is an issue: larger boards increase the combinatorial search space and therefore require proportionally larger populations and/or more generations to retain a comparable probability of finding a solution. 

Despite these limitations, Implementation~2 performs much better in practice than Implementation~1, but the problems with premature convergence apply to both implementations and to genetic algorithms in general.

\subsection{Solution representation}
The solution representation is an $n \times n$ matrix where each entry is a number in the range from 1 to $n$. The solution is valid if and only if every number in a row, a column, and a respective block is unique.