\section{Genetic Algorithm}\label{sec:algorithm}
This chapter describes the implementations of two algorithms used to solve Sudoku puzzles.
It starts out by briefly introducing depth-first search as the baseline measure and then goes on to explain how each of the genetic algorithms work.

\subsection{Baseline}
Depth-first search (DFS) is used as a deterministic baseline. It iteratively scans the board for the first empty cell, attempts candidate values 1\dots n, and backtracks to try alternative values if no candidate leads to a solution. This approach ensures a solution (given that the puzzle is solvable) and is simple to implement, which makes it a reliable reference for correctness and for measuring runtimes.

Algorithm \ref{alg:dfs} shows the implementation of the DFS algorithm in pseudo-code.

\begin{algorithm}[H]
\caption{Depth-first search algorithm}\label{alg:dfs}
\begin{adjustbox}{width=1\textwidth,left}
\begin{minipage}{\textwidth}
\begin{algorithmic}
\Require matrix
\Ensure \textbf{true} if solved, \textbf{false} otherwise
\State $n \gets$ length(matrix)
\For{$i \leftarrow 1$ \textbf{to} $n$}
  \For{$j \leftarrow 1$ \textbf{to} $n$}
    \If{matrix[$i,j$] = 0}
      \For{$num \leftarrow 1$ \textbf{to} $n$}
        \If{is\_valid\_move(matrix, $i$, $j$, $num$)}
          \State matrix[$i,j$] $\gets$ $num$
          \If{\Call{DFS}{matrix}} \State \Return \textbf{true} \EndIf
          \State matrix[$i,j$] $\gets$ 0
        \EndIf
      \EndFor
      \State \Return \textbf{false}
    \EndIf
  \EndFor
\EndFor
\State \Return \textbf{true}
\end{algorithmic}
\end{minipage}
\end{adjustbox}
\end{algorithm}

\subsection{Implementations}
This section presents and compares two genetic algorithms designed to solve Sudoku puzzles. Each implementation varies in its approach to selection, crossover, mutation strategies, and fitness evaluation.

The first GA implementation originated from initial project discussions and represents our first practical attempt to apply standard genetic operators to Sudoku. The second implementation builds on that design and performs better in general, which is why we use it as the representative GA in the following chapters.

Nevertheless, we decided not to omit the first GA from this paper, because it represents the iterative approach to finding an optimized solution, and it shows which algorithms tend to not work as good for Sudoku compared to the algorithms in the latter implementation.

The following sections document these algorithms and use the Sudoku board shown in Figure \ref{fig:initial-sudoku} as a reference for visualizing the selection and mutation step.

\begin{figure}[H]
\centering
\resizebox{0.5\textwidth}{!}{
  \begin{minipage}{\textwidth}
    \begin{sudoku}
    | |2| | | | | |3|1|.
    |7| | | | |3| | | |.
    | | | |1|4| |2|9| |.
    | |5|2|7|6|4| |1|8|.
    | |6|3| |1|2|7|5|9|.
    | |7|8| | | |4| | |.
    |2| | |3|7| | | |5|.
    | |1| | | | |9| | |.
    |5|4| | |8|1| | | |.
    \end{sudoku}
  \end{minipage}%
}
\caption{Initial Sudoku puzzle}
\label{fig:initial-sudoku}
\end{figure}

\subsubsection{Implementation 1}\label{sec:impl-1}
Algorithm \ref{alg:impl-1} initializes a population by randomly filling empty cells and then iteratively evolves it using selection, per-cell crossover and mutation for up to a fixed number of generations.
Most offspring are produced by top parents of the previous generation. Then, the population is replaced by the offspring, and eventually the best individual is returned.

A detailed description of how the fitness function, crossover and mutation work will be given afterwards.

\begin{algorithm}[H]
\caption{Genetic Algorithm 1}\label{alg:impl-1}
\begin{algorithmic}
\Require $initial\_sudoku$, $population\_size$, $mutation\_rate$, $max\_generations$
\Ensure Best individual found
\State $population \gets$ PopulateRandomly($initial\_sudoku$, $population\_size$)
\State $generation \gets 0$
\While{$generation < max\_generations$}
  \State $population \gets$ SortByFitness($population$) \Comment{descending order}
  \If{Fitness(first($population$)) = $max\_fitness$}
    \State \Return first($population$)
  \EndIf
  \State $next\_generation \gets \emptyset$
  \For{$i \gets 1 \ \textbf{to} \ population\_size \times 0.8$}
    \State $parent_1, parent_2 \gets$ Sample(top 20\% of $population$)
    \State $child \gets$ Crossover($parent_1$, $parent_2$)
    \State $child \gets$ Mutate($child$, $mutation\_rate$, $initial\_sudoku$)
    \State $next\_generation \gets next\_generation \cup \{child\}$
  \EndFor
  \For{$i \gets 1 \ \textbf{to} \ population\_size \times 0.2$}
    \State $parent_1, parent_2 \gets$ Sample($population$)
    \State $child \gets$ Crossover($parent_1$, $parent_2$)
    \State $child \gets$ Mutate($child$, $mutation\_rate$, $initial\_sudoku$)
    \State $next\_generation \gets next\_generation \cup \{child\}$
  \EndFor
  \State $population \gets next\_generation$
  \State $generation \gets generation + 1$
\EndWhile
\State $population \gets$ SortByFitness($population$) \Comment{descending order}
\State \Return first($population$)
\end{algorithmic}
\end{algorithm}


\paragraph{Fitness function}\label{par:ff-impl1} Let $R_i$, $C_j$ and $B_b$ denote the sets of distinct, non-zero digits present in row $i$, column $j$, and block $b$, respectively. Using zero-based indices $(i,j\in\{0,\dots,8\})$ the block index is
\[
b \;=\; 3\Big\lfloor\frac{i}{3}\Big\rfloor \;+\; \Big\lfloor\frac{j}{3}\Big\rfloor .
\]
The fitness of a board is the total number of distinct digits across all rows, columns and 3\(\times\)3 blocks:
\[
F \;=\; \sum_{i=0}^{8} |R_i| \;+\; \sum_{j=0}^{8} |C_j| \;+\; \sum_{b=0}^{8} |B_b|.
\]
This definition results in a maximum fitness score of $243$ for 9$\times$9 boards.

Our fitness function is inspired by prior work that sums distinct digits per row and column \cite{Sato2011}; we extend that idea by also counting distinct digits in each 3$\times$3 block to better reflect Sudoku constraints.

\paragraph{Crossover} A new individual is created by crossing over two parents. The crossover process simply iterates over all the tiles that were not given in the initial puzzle and takes the value for that tile from either parent to copy it to the child.

\begin{figure}[H]
  \centering
  {\setlength{\tabcolsep}{-9pt}
  \renewcommand{\arraystretch}{1.5}
   \begin{tabular}{c c c c c}
    % first board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |6|2|9|5|7|6|7|3|1|.
        |7|8|5|6|9|3|1|2|7|.
        |1|3|4|1|4|7|2|9|5|.
        |4|5|2|7|6|4|4|1|8|.
        |9|6|3|8|1|2|7|5|9|.
        |9|7|8|2|9|5|4|6|2|.
        |2|2|6|3|7|7|9|4|5|.
        |4|1|6|2|2|3|9|7|9|.
        |5|4|1|2|8|1|3|4|8|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % plus sign
    {\begin{adjustbox}{valign=c}\Large$+$\end{adjustbox}}
    &
    % second board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |8|2|6|7|7|5|7|3|1|.
        |7|1|3|9|8|3|8|2|4|.
        |1|5|5|1|4|7|2|9|3|.
        |9|5|2|7|6|4|1|1|8|.
        |4|6|3|9|1|2|7|5|9|.
        |3|7|8|5|9|1|4|6|3|.
        |2|8|7|3|7|1|7|4|5|.
        |3|1|6|4|2|3|9|7|2|.
        |5|4|4|2|8|1|3|4|3|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % equals sign
    {\begin{adjustbox}{valign=c}\Large$=$\end{adjustbox}}
    &
    % third board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |8|2|9|7|7|6|7|3|1|.
        |7|1|5|6|8|3|1|2|4|.
        |1|3|5|1|4|7|2|9|5|.
        |9|5|2|7|6|4|1|1|8|.
        |9|6|3|8|1|2|7|5|9|.
        |3|7|8|5|9|1|4|6|3|.
        |2|2|6|3|7|7|7|4|5|.
        |4|1|6|4|2|3|9|7|9|.
        |5|4|1|2|8|1|3|4|3|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
   \end{tabular}
  }
  \caption{Exemplary selection step according to Implementation 1}
  \label{fig:impl-1-selection}
\end{figure}

In the figure above, two parents (left and middle) of the current generation form an individual of the next generation (right).
One area for improvement is evident in row 7: Parent~1 contains two occurrences of the digit 7 and Parent~2 contains three. The offspring also has three 7s, while it would have been possible to generate a row with all distinct digits, namely \textbf{286371945}.

\paragraph{Mutation} After the creation, the new individual undergoes up to $mutation\_amount$ mutations. A mutation means that a random tile changes its value. If that tile, however, happens to be a given tile from the initial puzzle, it is not altered. 

\begin{figure}[h]
  \centering
  {\setlength{\tabcolsep}{0pt}
  \renewcommand{\arraystretch}{1.5}
   \begin{tabular}{c c c}
    % first board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |8|2|9|7|7|6|7|3|1|.
        |7|1|5|6|8|3|1|2|4|.
        |1|3|5|1|4|7|2|9|5|.
        |9|5|2|7|6|4|1|1|8|.
        |9|6|3|8|1|2|7|5|9|.
        |3|7|8|5|9|1|4|6|3|.
        |2|2|6|3|7|7|7|4|5|.
        |4|1|6|4|2|3|9|7|9|.
        |5|4|1|2|8|1|3|4|3|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % plus sign
      {\begin{adjustbox}{valign=c}
       \shortstack{mutation\\[2pt]\Large$\longrightarrow$}
     \end{adjustbox}}
    &
    % second board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
        |8|2|9|7|7|6|7|3|1|.
        |7|1|5|6|8|3|1|2|4|.
        |1|3|5|1|4|7|2|9|5|.
        |9|5|2|7|6|4|1|1|8|.
        |9|6|3|8|1|2|7|5|9|.
        |3|7|8|5|9|1|4|6|3|.
        |2|2|6|3|7|7|7|7|5|.
        |4|1|6|4|2|3|9|7|9|.
        |5|4|1|2|8|1|3|4|3|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
   \end{tabular}
  }
  \caption{Exemplary mutation step according to Implementation 1}
  \label{fig:impl-1-mutation}
\end{figure}

Figure \ref{fig:impl-1-mutation} illustrates a mutation step with $mutation\_amount =2$. Meanwhile, only a single tile (row 7, column 7) was actually modified to have the value 7. The other candidate position coincided with a given cell and therefore could not be changed. This example highlights a weakness of the implementation: mutations can be wasted when selected positions are immutable, and a single mutation may decrease fitness significantly by introducing additional conflicts (the number of 7's increased to 4 in the respective row, to 2 in the respective column, and to 3 in the respective grid).

\paragraph{Problem}
This implementation leads to a situation where the diversity of the population decreases rapidly, resulting in convergence to suboptimal solutions. On many runs, the algorithm creates more than 100,000 generations before finding a valid solution.  
To counter this problem, we have tried to adjust the mutation rate and the population size as well as introducing new random individuals in each generation. However, these adjustments only led to marginal improvements in performance.

\subsubsection{Implementation 2}
\label{sec:impl-2}
Algorithm \ref{alg:impl-2} creates a population with unique rows and improves it using elitism, tournament selection, row-wise crossover and swap-based mutation. Each generation the population is evaluated, the best \(elite\_size\) individuals are carried over unchanged, and the remaining offspring are produced from parents chosen by tournament selection. Children copy whole rows from parents to preserve row validity and then undergo mutations that swap non-given tiles within rows. The algorithm terminates when a perfect solution is found or the maximum number of generations is reached.

A description of the fitness function, crossover, and mutation will once again be given afterwards.

\begin{algorithm}[H]
\caption{Genetic Algorithm 2}\label{alg:impl-2}
\begin{algorithmic}
\Require $population\_size$, $elite\_size$, $max\_generations$
\Ensure Best individual found
\State $population \gets$ PopulateWithUniqueRows($population\_size$)
\State $best\_individual \gets$ arbitrary element of $population$
\For{$generation \gets 1 \ \textbf{to} \ max\_generations$}
  \ForAll{$ind \in population$}
    \State ComputeFitness($ind$)
  \EndFor
  \State $population \gets$ SortByFitness($population$) \Comment{ascending order}
  \If{Fitness(first($population$)) $<$ Fitness($best\_individual$)}
    \State $best\_individual \gets$ first($population$)
  \EndIf
  \If{Fitness($best\_individual$) = 0}
    \State \Return $best\_individual$
  \EndIf
  \State $next\_generation \gets$ Top($elite\_size$, $population$)
  \State $parents \gets$ TournamentSelection($population$)
  \For{$i \gets 1 \ \textbf{to} \ population\_size - elite\_size \ \textbf{step} \ 2$}
    \State $parent_1 \gets parents[i]$
    \State $parent_2 \gets parents[i+1]$
    \State $child_1 \gets$ Crossover($parent_1, parent_2$)
    \State $next\_generation \gets next\_generation \cup \{child_1\}$
    \If{$|next\_generation| < population\_size$}
      \State $child_2 \gets$ Crossover($parent_2, parent_1$)
      \State $next\_generation \gets next\_generation \cup \{child_2\}$
    \EndIf
  \EndFor
  \State $population \gets next\_generation$
\EndFor
\State \Return $best\_individual$
\end{algorithmic}
\end{algorithm}

\paragraph{Fitness function} Let \(C_j\) and \(B_b\) denote the sets of distinct, non-zero digits in column \(j\) and block \(b\), respectively, and let \(n\) be the board size. The fitness function counts the number of duplicates in each column, and 3x3 subgrid:
\[
F \;=\; \sum_{j=0}^{n-1} \bigl(n - |C_j|\bigr) \;+\; \sum_{b=0}^{n-1} \bigl(n - |B_b|\bigr).
\]
A value \(F=0\) indicates a valid solution. This formulation is similar to that of the previous work , which also iterates over columns and sub-blocks but assigns a value of 0 when a unit is valid and 1 when it contains any violation\cite{Wang2024}. By contrast, our fitness function counts the number of duplicate digits per column and block, giving a more fine-grained penalty (e.g. a column with three duplicated entries contributes 3 rather than 1).

\paragraph{Crossover} The crossover step is done by iterating through the rows of the sudoku board and copying each row from either parent. This ensures that the children will still respect the uniqueness of numbers in each row.

\begin{figure}[H]
  \centering
  {\setlength{\tabcolsep}{-9pt}
  \renewcommand{\arraystretch}{1.5}
   \begin{tabular}{c c c c c}
    % first board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |9|2|4|6|7|8|5|3|1|.
          |7|9|1|5|2|3|8|6|4|.
          |8|3|5|1|4|6|2|9|7|.
          |3|5|2|7|6|4|9|1|8|.
          |4|6|3|8|1|2|7|5|9|.
          |6|7|8|5|3|9|4|1|2|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|2|6|5|9|8|4|.
          |5|4|9|6|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % plus sign
    {\begin{adjustbox}{valign=c}\Large$+$\end{adjustbox}}
    &
    % second board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |8|2|4|7|9|6|5|3|1|.
          |7|9|1|5|2|3|6|8|4|.
          |3|6|7|1|4|8|2|9|5|.
          |3|5|2|7|6|4|9|1|8|.
          |8|6|3|4|1|2|7|5|9|.
          |1|7|8|5|3|9|4|2|6|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|8|5|6|9|4|2|.
          |5|4|6|9|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % equals sign
    {\begin{adjustbox}{valign=c}\Large$=$\end{adjustbox}}
    &
    % third board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |8|2|4|7|9|6|5|3|1|.
          |7|9|1|5|2|3|6|8|4|.
          |8|3|5|1|4|6|2|9|7|.
          |3|5|2|7|6|4|9|1|8|.
          |8|6|3|4|1|2|7|5|9|.
          |1|7|8|5|3|9|4|2|6|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|2|6|5|9|8|4|.
          |5|4|6|9|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
   \end{tabular}
  }
  \caption{Exemplary selection step according to Implementation 2}
  \label{fig:impl-2-selection}
\end{figure}

In Figure~\ref{fig:impl-2-selection}, it is easy to see that the very first row is taken from the first parent (left), while row 8 is copied from the second parent (center). As a result of the crossover step, duplicate numbers can now only emerge in columns or subgrids, which is an improvement compared to \nameref{sec:impl-1}.

\paragraph{Mutation} For the mutation, we iterate all rows and select two non-given tiles in that row to swap their values with probability \(mutation\_rate\). This row-wise swap was inspired by swap-mutations within subgrids and is also consistent with other work that performs swap mutations inside random rows to ensure row constraints are preserved \cite{Wang2024, Sato2011, Mantere2007}. The cited paper additionally applies a reinitialisation mutation step, but in our implementation we only adopt the row-swap component of the mutation logic.

To increase diversity when the fitness stagnates over $generations\_stuck$ generations, we also introduce an adaptive mutation rate which increases the mutation rate temporarily until progress resumes. The mutation rate is capped at a maximum of \(0.3\), which alignes with the value used in related work \cite{Sato2011}.

\begin{figure}[H]
  \centering
  {\setlength{\tabcolsep}{0pt}
  \renewcommand{\arraystretch}{1.5}
   \begin{tabular}{c c c}
    % first board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |8|2|4|7|9|6|5|3|1|.
          |7|9|1|5|2|3|6|8|4|.
          |8|3|5|1|4|6|2|9|7|.
          |3|5|2|7|6|4|9|1|8|.
          |8|6|3|4|1|2|7|5|9|.
          |1|7|8|5|3|9|4|2|6|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|2|6|5|9|8|4|.
          |5|4|6|9|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
    & % plus sign
      {\begin{adjustbox}{valign=c}
       \shortstack{mutation\\[2pt]\Large$\longrightarrow$}
     \end{adjustbox}}
    &
    % second board
    \begin{adjustbox}{width=0.38\textwidth,valign=c}
      \begin{minipage}{\linewidth}
        \begin{sudoku}
          |8|2|4|6|9|7|5|3|1|.
          |7|9|1|5|2|3|6|8|4|.
          |8|3|5|1|4|6|2|9|7|.
          |3|5|2|7|6|4|9|1|8|.
          |4|6|3|8|1|2|7|5|9|.
          |1|7|8|5|3|9|4|2|6|.
          |2|9|6|3|7|4|1|8|5|.
          |3|1|7|2|6|5|9|8|4|.
          |5|4|6|9|8|1|3|2|7|.
        \end{sudoku}
      \end{minipage}
    \end{adjustbox}
   \end{tabular}
  }
  \caption{Exemplary mutation step according to Implementation 2}
  \label{fig:impl-2-mutation}
\end{figure}

Figure~\ref{fig:impl-2-mutation} shows a mutation step with a rate of 20\%, leading to swap-mutations in row 1 and row 5. 

\paragraph{Problem}
The second genetic algorithm also often converges to local optima and loses diversity, limiting further improvement. To overcome stagnation we reinitialised a large portion of the population after the fitness has stopped decreasing which is related to the cataclysmic mutation/restart procedure discussed in \textit{Solving, rating and generating sudoku puzzles with GA}\cite{Mantere2007}. This strategy often restored search progress but did not fully eliminate premature convergence. Furthermore, scalability remains an issue: larger boards increase the combinatorial search space and therefore require proportionally larger populations and/or more generations to retain a comparable probability of finding a solution.

Despite these limitations, Implementation~2 performs much better in practice than Implementation~1, but the problems with premature convergence apply to both implementations and to genetic algorithms in general.

\subsection{Solution representation}
The solution representation is an $n \times n$ matrix where each entry is a number in the range from 1 to $n$. The solution is valid if and only if every number in a row, a column, and a respective block is unique.