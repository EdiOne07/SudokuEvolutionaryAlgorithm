\section{Sudoku Puzzle Problem}
\label{sec:problem_description}

\subsection{Problem Description}
{Sudoku is a Japanese logical game that is played on a $9 \times 9$ grid, that are further divided into $3 \times 3$ subgrids. The objective of the game is to fill the grid with digits from 1 to 9, ensuring that each row, column, and subgrid contains each digit exactly once\cite{Mantere2007}. The puzzle starts with some cells already filled in, and the player must use logic and respect the base rule of the game in order to finish the puzzle.}
{\newline}
{\newline Sudoku puzzles can vary in difficulty based on how many numbers they start with, the arrangement of these numbers and even the varying size of the Sudoku. They can go beyond the standard $9 \times 9$ grid, for example to $16 \times 16$ or $25 \times 25$ that we also use to test our algorithm on. Thus, we can think of the Sudoku problem as a graph coloring problem if it were to be expressed in a mathematical context. The $9 \times 9$ grid can be seen as graph that has 81 vertices, namely one vertex for each cell. Each vertex can be labeled with an ordered pair (x,y), where x and y are integers between 1 and 9 \cite{WikiMathematics}. Two distinct vertices (x1,y1) and (x2,y2) are connected by an edge if and only if they are in the same row, column or subgrid:}
\begin {itemize}
    \item $x1 = x2$, which translates to same row
    \item $y1 = y2$, which translates to same column
    \item $\lfloor (x1-1)/3 \rfloor = \lfloor (x2-1)/3 \rfloor$ and $\lfloor (y1-1)/3 \rfloor = \lfloor (y2-1)/3 \rfloor$ which translates as same subgrid
\end {itemize}
{As previously mentioned, the puzzle is completed when all the vertices have an integer between 1 and 9 assigned to them, in such a way that vertices that are joined by an edge don't have the same number assigned to them. }

\subsection{Evolutionary Approach}
{While Sudoku has a deterministic solution, evolutionary algorithms can be used in order to compare their performance with more traditional approaches such as the depth-first search algorithm. The paper \textit{Evolutionary Algorithms and Sudoku} managed to implement an evolutionary algorithm that could very efficiently solve easy Sudoku puzzles\cite{Moraglio}. The downside of that algorithm it that it is not as efficient when solving medium or hard puzzles.
The way they approached the algorithm was to test constraints on different sets of spaces, namely the Hamming space and the Row Swap space. The drawn conclusions were that even though the Hamming space had a smoother fitness landscape, in the end the Row Swap space was more efficient and produced more optimal results.}
{\newline}
{\newline Another approach was taken in the paper \textit{Solving sudokuâ€™s by evolutionary algorithms with pre-processing}, where pre-processing was involved\cite{Amil2019}. The pre-processing involved filling some sure numbers in the Sudoku through different methods, such as the naked single method, hidden single method, full house and lone rangers. The best method depends on on the type of puzzle, since each method performed differently depending on the case.
After the pre-processing was done, different evolutionary algorithms were tested, including a genetic algorithm that uses crossover and mutation operators, a genetic algorithm that uses an ant colony optimization and one that firstly pre-processes the board and then applies the said genetic algorithm. The fitness function used in this paper is made of three components: the first one minimizes missing digits into rows and columns, the second one uses a sort of aging penalty in order to prevent the same best individual persisting over generations. Finally, the third one penalizes violations where a candidate digit conflicts with a given clue in its row or column.
The conclusion they arrived at was that solving the Sudoku puzzle is faster when pre-processing is involved and that a hybrid algorithm between genetic algorithm and ant colony optimization is the most efficient with every type of Sudoku puzzle.  }
{\newline}
{\newline Lastly, the paper that influenced our approach the most was \textit{Solving, rating and generating sudoku puzzles with GA}, which uses the genetic algorithm with Darwinian evolution as its inspiration\cite{Mantere2007}. This implies that each individual in the population is tested against a fitness function, that further decides whether the individual should be removed from the population or used as a parent to get closer to the desired result.
New individuals are created through the use of crossover and mutation. Mutations is restricted to sub-blocks, using swap mutation as the primary operator. Further on, it was observed in the paper that using a cataclysmic mutation, specifically a restart of the population, every 2000 generations brought the best results when no solution was found. Similar to our project, the authors experimented with different fitness functions, but ended up using a function that counts missing or duplicate digits in each row and column, assigning penalties. The optimal value of the fitness function is 0. Furthermore, the authors introduced an aging penalty, adding $+1$ to the fitness of the best solution if it remains unchanged.
The conclusion the paper arrived at is that the genetic algorithm could solve Sudoku puzzles efficiently, and even if there are better performing algorithms, they sometimes would fail to solve puzzles that the genetic algorithm could solve.}
{\newline}
{\newline The motivation for our project is straightforward. We want to explore if a streamlined evolutionary algorithm with carefully chosen operators can achieve better performances than naive search algorithms, such as the depth-first search algorithm. As previously mentioned, our main inspiration for the evolutionary algorithm was the paper \textit{Solving, rating and generating sudoku puzzles with GA}, thus we implemented an evolutionary algorithm that uses mutation and crossover operators while also taking an elitist approach regarding the selection of the parents\cite{Mantere2007}.
Additionally, we also want to investigate the scalability of our evolutionary algorithm, thus we also tested it on a $16 \times 16$ and $25 \times 25$ puzzles. Evolutionary algorithms are well suited for this type of problem because they can handle large solution spaces effectively, balance exploration and exploitation, and adapt by integrating problem-specific heuristics.
We believe that the Sudoku problem is a great choice for analyzing all the key aspects of evolutionary algorithms.}

