\section{Sudoku Puzzle Problem}
\label{sec:problem_description}
\subsection{Problem Description}
{Sudoku is a Japanese logical game that is played on a $9 \times 9$ grid, that are further divided into $3 \times 3$ subgrids. The objective of the game is to fill the grid with digits from 1 to 9, ensuring that each row, column, and subgrid contains each digit exactly once\cite{Mantere2007}. The puzzle starts with some cells already filled in, and the player must use logic and respect the base rule of the game in order to finish the puzzle.}
{\newline}
{\newline Sudoku puzzles can vary in difficulty based on how many numbers they start with, the arrangement of these numbers and even the varying size of the sudoku, since they can go beyond the standard $9 \times 9$ grid, similar to the $25 \times 25$ grid we used to test our algorithm with. Thus, we can think of the sudoku problem as a graph coloring problem if it were to be expressed in a mathematical context. The $9 \times 9$ grid can be seen as graph that has 81 vertices, namely one vertex for each cell. Each vertex can be labeled with an ordered pair (x,y), where x and y are integers between 1 and 9 \cite{WikiMathematics}. Two distinct vertices (x1,y1) and (x2,y2) are connected by an edge if and only if they are in the same row, column or subgrid:}
\begin {itemize}
    \item $x1 = x2$, which translates as same row
    \item $y1 = y2$, which translates as same column
    \item $\lfloor (x1-1)/3 \rfloor = \lfloor (x2-1)/3 \rfloor$ and $\lfloor (y1-1)/3 \rfloor = \lfloor (y2-1)/3 \rfloor$ which translates as same subgrid
\end {itemize}
{As previously mentioned, the puzzle is completed when all the vertices have an integer between 1 and 9 assigned to them, in such a way that vertices that are joined by an edge don't have the same number assigned to them. }
\subsection{Evolutionary Approach}
{While Sudoku has a deterministic solution, evolutionary algorithms can be used in order to compare their performance with more traditional approaches such as the depth-first search algorithm. As it is mentioned in the paper \textit{Evolutionary Algorithms and Sudoku}, they managed to implement an evolutionary algorithm that could solve very efficiently easy Sudoku puzzles\cite{Moraglio}. The downside of their algorithm, was that it wasn't as efficient when it came down to solving medium or hard puzzles.
The way, they approached the algorithm was to test constraints on different sets of spaces, namely the Hamming space and the Row Swap space. The drawn conclusions were that even though the Hamming space had a smoother fitness landscape, in the end the Row Swap space was more efficient and produced more optimal results.}
{\newline}
{\newline Another approach was taken in the paper \textit{Solving sudokuâ€™s by evolutionary algorithms with pre-processing}, where pre-processing was involved\cite{Amil2019}. The pre-processing involved filling some sure numbers in the sudoku, through different methods, such as the naked single method, hidden single method, full house and lone rangers. The way in which a method was selected to be used was based on the type of puzzle, since each method has different efficency depending on the case.
After the pre-processing was done, different evolutionary algorithms were tested, such as a genetic algorithm that uses crossover and mutation operators, a genetic algorithm that uses an ant colony optimization and finally one that firstly pre-processes the board and then applies the said genetic algorithm. The fitness function used in this paper is made of three components: first one minimizes missing digits into rows and columns, the second one uses a sort of aging penalty, in order to prevent the same best individual persisting over generations. Finally, the third one penalizes violations where a candidate digit conflicts with a given clue in its row or column.
The conclusion they arrived to was that solving the sudoku puzzle was faster when pre-processing was involved and that a hybrid algorithm between genetic algorithm and ant colony optimization was the most efficient with every type of sudoku puzzle.  }
{\newline}
{\newline Lastly, the paper that influenced our approach the most was \textit{Solving, rating and generating sudoku puzzles with GA}, which uses the genetic algorithm with Darwinian evolution as its inspiration\cite{Mantere2007}. This implies that each individual in the population is tested against a fitness function, that further decides whether the individual should be removed from the population or used as a parent to get closer to the desired result.
New individuals are created through the use of crossover and mutation. Mutations is restricted to sub-blocks, using swap mutation as the primary operator. Further on, it was observed in the paper that using a cataclysmic mutation, specifically a restart of the population, every 2000 generation brought the best results when no solution was found. Similar to our project, the authours experimented with different fitness functions, but ended up using a function that counts missing or duplicate digits in each row and column, assigning penalties. This being said, the optimal value of the fitness function would be 0. On top of that, the authors introduced an aging penalty, adding $+1$ to the fitness of the best solution if it remains unchanged.
The conclusion the paper arrived to was that the genetic algorithm could solve sudoku puzzles quite efficiently, and even if there were better performing algorithms, they sometimes would fail at puzzles that the genetic algorithm could solve.}
{\newline}
{\newline The motivation for our project is quite straightforward. We want to explore if a streamlined evolutionary algorithm with carefully chosen operators can achieve better perfromances than already existing and efficient search algorithms, such as the depth-first search algorithm. As previously mentioned our main inspiration for the evolutionary algorithm was the paper \textit{Solving, rating and generating sudoku puzzles with GA}, thus we implemented an evolutionary algorithm that uses mutation and crossover operators, while also taking an elitist approach regarding the selection of the parents\cite{Mantere2007}.
On top of that, we also wanted to investigate the scalability of our evolutionary algorithm, thus we also tested it on a $16 \times 16$ puzzle. Evolutionary algorithms are well suited for this type of problem, because they can handle large solution spaces effectively, balance exploration and explotation, and adapt by integrating problem-specific heuristics.
All being considered, we believe that the Sudoku problem is a great choice for analyzing all those key aspects of evolutionary algorithms.}

